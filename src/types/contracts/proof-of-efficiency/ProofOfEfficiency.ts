/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace PolygonZkEVM {
  export type InitializePackedParametersStruct = {
    admin: PromiseOrValue<string>;
    trustedSequencer: PromiseOrValue<string>;
    pendingStateTimeout: PromiseOrValue<BigNumberish>;
    trustedAggregator: PromiseOrValue<string>;
    trustedAggregatorTimeout: PromiseOrValue<BigNumberish>;
  };

  export type InitializePackedParametersStructOutput = [
    string,
    string,
    BigNumber,
    string,
    BigNumber
  ] & {
    admin: string;
    trustedSequencer: string;
    pendingStateTimeout: BigNumber;
    trustedAggregator: string;
    trustedAggregatorTimeout: BigNumber;
  };

  export type BatchDataStruct = {
    transactions: PromiseOrValue<BytesLike>;
    globalExitRoot: PromiseOrValue<BytesLike>;
    timestamp: PromiseOrValue<BigNumberish>;
    minForcedTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type BatchDataStructOutput = [string, string, BigNumber, BigNumber] & {
    transactions: string;
    globalExitRoot: string;
    timestamp: BigNumber;
    minForcedTimestamp: BigNumber;
  };

  export type ForcedBatchDataStruct = {
    transactions: PromiseOrValue<BytesLike>;
    globalExitRoot: PromiseOrValue<BytesLike>;
    minForcedTimestamp: PromiseOrValue<BigNumberish>;
  };

  export type ForcedBatchDataStructOutput = [string, string, BigNumber] & {
    transactions: string;
    globalExitRoot: string;
    minForcedTimestamp: BigNumber;
  };
}

export interface ProofOfEfficiencyInterface extends utils.Interface {
  functions: {
    "acceptAdminRole()": FunctionFragment;
    "activateEmergencyState(uint64)": FunctionFragment;
    "admin()": FunctionFragment;
    "batchFee()": FunctionFragment;
    "batchNumToStateRoot(uint64)": FunctionFragment;
    "bridgeAddress()": FunctionFragment;
    "calculateRewardPerBatch()": FunctionFragment;
    "chainID()": FunctionFragment;
    "consolidatePendingState(uint64)": FunctionFragment;
    "deactivateEmergencyState()": FunctionFragment;
    "forceBatch(bytes,uint256)": FunctionFragment;
    "forcedBatches(uint64)": FunctionFragment;
    "forkID()": FunctionFragment;
    "getCurrentBatchFee()": FunctionFragment;
    "getInputSnarkBytes(uint64,uint64,bytes32,bytes32,bytes32)": FunctionFragment;
    "getLastVerifiedBatch()": FunctionFragment;
    "globalExitRootManager()": FunctionFragment;
    "initialize((address,address,uint64,address,uint64),bytes32,string,string,string)": FunctionFragment;
    "isEmergencyState()": FunctionFragment;
    "isPendingStateConsolidable(uint64)": FunctionFragment;
    "lastBatchSequenced()": FunctionFragment;
    "lastForceBatch()": FunctionFragment;
    "lastForceBatchSequenced()": FunctionFragment;
    "lastPendingState()": FunctionFragment;
    "lastPendingStateConsolidated()": FunctionFragment;
    "lastTimestamp()": FunctionFragment;
    "lastVerifiedBatch()": FunctionFragment;
    "matic()": FunctionFragment;
    "multiplierBatchFee()": FunctionFragment;
    "networkName()": FunctionFragment;
    "overridePendingState(uint64,uint64,uint64,uint64,bytes32,bytes32,uint256[2],uint256[2][2],uint256[2])": FunctionFragment;
    "owner()": FunctionFragment;
    "pendingAdmin()": FunctionFragment;
    "pendingStateTimeout()": FunctionFragment;
    "pendingStateTransitions(uint256)": FunctionFragment;
    "proveNonDeterministicPendingState(uint64,uint64,uint64,uint64,bytes32,bytes32,uint256[2],uint256[2][2],uint256[2])": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "rollupVerifier()": FunctionFragment;
    "sequenceBatches((bytes,bytes32,uint64,uint64)[],address)": FunctionFragment;
    "sequenceForceBatches((bytes,bytes32,uint64)[])": FunctionFragment;
    "sequencedBatches(uint64)": FunctionFragment;
    "setMultiplierBatchFee(uint16)": FunctionFragment;
    "setPendingStateTimeout(uint64)": FunctionFragment;
    "setTrustedAggregator(address)": FunctionFragment;
    "setTrustedAggregatorTimeout(uint64)": FunctionFragment;
    "setTrustedSequencer(address)": FunctionFragment;
    "setTrustedSequencerURL(string)": FunctionFragment;
    "setVerifyBatchTimeTarget(uint64)": FunctionFragment;
    "transferAdminRole(address)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "trustedAggregator()": FunctionFragment;
    "trustedAggregatorTimeout()": FunctionFragment;
    "trustedSequencer()": FunctionFragment;
    "trustedSequencerURL()": FunctionFragment;
    "verifyBatchTimeTarget()": FunctionFragment;
    "verifyBatches(uint64,uint64,uint64,bytes32,bytes32,uint256[2],uint256[2][2],uint256[2])": FunctionFragment;
    "verifyBatchesTrustedAggregator(uint64,uint64,uint64,bytes32,bytes32,uint256[2],uint256[2][2],uint256[2])": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "acceptAdminRole"
      | "activateEmergencyState"
      | "admin"
      | "batchFee"
      | "batchNumToStateRoot"
      | "bridgeAddress"
      | "calculateRewardPerBatch"
      | "chainID"
      | "consolidatePendingState"
      | "deactivateEmergencyState"
      | "forceBatch"
      | "forcedBatches"
      | "forkID"
      | "getCurrentBatchFee"
      | "getInputSnarkBytes"
      | "getLastVerifiedBatch"
      | "globalExitRootManager"
      | "initialize"
      | "isEmergencyState"
      | "isPendingStateConsolidable"
      | "lastBatchSequenced"
      | "lastForceBatch"
      | "lastForceBatchSequenced"
      | "lastPendingState"
      | "lastPendingStateConsolidated"
      | "lastTimestamp"
      | "lastVerifiedBatch"
      | "matic"
      | "multiplierBatchFee"
      | "networkName"
      | "overridePendingState"
      | "owner"
      | "pendingAdmin"
      | "pendingStateTimeout"
      | "pendingStateTransitions"
      | "proveNonDeterministicPendingState"
      | "renounceOwnership"
      | "rollupVerifier"
      | "sequenceBatches"
      | "sequenceForceBatches"
      | "sequencedBatches"
      | "setMultiplierBatchFee"
      | "setPendingStateTimeout"
      | "setTrustedAggregator"
      | "setTrustedAggregatorTimeout"
      | "setTrustedSequencer"
      | "setTrustedSequencerURL"
      | "setVerifyBatchTimeTarget"
      | "transferAdminRole"
      | "transferOwnership"
      | "trustedAggregator"
      | "trustedAggregatorTimeout"
      | "trustedSequencer"
      | "trustedSequencerURL"
      | "verifyBatchTimeTarget"
      | "verifyBatches"
      | "verifyBatchesTrustedAggregator"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "acceptAdminRole",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "activateEmergencyState",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "admin", values?: undefined): string;
  encodeFunctionData(functionFragment: "batchFee", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "batchNumToStateRoot",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "bridgeAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calculateRewardPerBatch",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "chainID", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "consolidatePendingState",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "deactivateEmergencyState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "forceBatch",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "forcedBatches",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "forkID", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getCurrentBatchFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getInputSnarkBytes",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLastVerifiedBatch",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "globalExitRootManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PolygonZkEVM.InitializePackedParametersStruct,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isEmergencyState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isPendingStateConsolidable",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "lastBatchSequenced",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastForceBatch",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastForceBatchSequenced",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastPendingState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastPendingStateConsolidated",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lastVerifiedBatch",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "matic", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "multiplierBatchFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "networkName",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "overridePendingState",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingAdmin",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pendingStateTimeout",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pendingStateTransitions",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "proveNonDeterministicPendingState",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rollupVerifier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sequenceBatches",
    values: [PolygonZkEVM.BatchDataStruct[], PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "sequenceForceBatches",
    values: [PolygonZkEVM.ForcedBatchDataStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "sequencedBatches",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setMultiplierBatchFee",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPendingStateTimeout",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrustedAggregator",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrustedAggregatorTimeout",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrustedSequencer",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrustedSequencerURL",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setVerifyBatchTimeTarget",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferAdminRole",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "trustedAggregator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "trustedAggregatorTimeout",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "trustedSequencer",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "trustedSequencerURL",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "verifyBatchTimeTarget",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "verifyBatches",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyBatchesTrustedAggregator",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "acceptAdminRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "activateEmergencyState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "admin", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "batchFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "batchNumToStateRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "bridgeAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateRewardPerBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "chainID", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "consolidatePendingState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deactivateEmergencyState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "forceBatch", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "forcedBatches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "forkID", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentBatchFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInputSnarkBytes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastVerifiedBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "globalExitRootManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isEmergencyState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isPendingStateConsolidable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastBatchSequenced",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastForceBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastForceBatchSequenced",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastPendingState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastPendingStateConsolidated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lastVerifiedBatch",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "matic", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "multiplierBatchFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "networkName",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "overridePendingState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingStateTimeout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingStateTransitions",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proveNonDeterministicPendingState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rollupVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sequenceBatches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sequenceForceBatches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "sequencedBatches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMultiplierBatchFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPendingStateTimeout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTrustedAggregator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTrustedAggregatorTimeout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTrustedSequencer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTrustedSequencerURL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setVerifyBatchTimeTarget",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferAdminRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trustedAggregator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trustedAggregatorTimeout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trustedSequencer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trustedSequencerURL",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyBatchTimeTarget",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyBatches",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyBatchesTrustedAggregator",
    data: BytesLike
  ): Result;

  events: {
    "AcceptAdminRole(address)": EventFragment;
    "ConsolidatePendingState(uint64,bytes32,uint64)": EventFragment;
    "EmergencyStateActivated()": EventFragment;
    "EmergencyStateDeactivated()": EventFragment;
    "ForceBatch(uint64,bytes32,address,bytes)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "OverridePendingState(uint64,bytes32,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "ProveNonDeterministicPendingState(bytes32,bytes32)": EventFragment;
    "SequenceBatches(uint64)": EventFragment;
    "SequenceForceBatches(uint64)": EventFragment;
    "SetMultiplierBatchFee(uint16)": EventFragment;
    "SetPendingStateTimeout(uint64)": EventFragment;
    "SetTrustedAggregator(address)": EventFragment;
    "SetTrustedAggregatorTimeout(uint64)": EventFragment;
    "SetTrustedSequencer(address)": EventFragment;
    "SetTrustedSequencerURL(string)": EventFragment;
    "SetVerifyBatchTimeTarget(uint64)": EventFragment;
    "TransferAdminRole(address)": EventFragment;
    "UpdateZkEVMVersion(uint64,uint64,string)": EventFragment;
    "VerifyBatches(uint64,bytes32,address)": EventFragment;
    "VerifyBatchesTrustedAggregator(uint64,bytes32,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AcceptAdminRole"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ConsolidatePendingState"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EmergencyStateActivated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "EmergencyStateDeactivated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ForceBatch"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OverridePendingState"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ProveNonDeterministicPendingState"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SequenceBatches"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SequenceForceBatches"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetMultiplierBatchFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetPendingStateTimeout"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetTrustedAggregator"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "SetTrustedAggregatorTimeout"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetTrustedSequencer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetTrustedSequencerURL"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SetVerifyBatchTimeTarget"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferAdminRole"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateZkEVMVersion"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VerifyBatches"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "VerifyBatchesTrustedAggregator"
  ): EventFragment;
}

export interface AcceptAdminRoleEventObject {
  newAdmin: string;
}
export type AcceptAdminRoleEvent = TypedEvent<
  [string],
  AcceptAdminRoleEventObject
>;

export type AcceptAdminRoleEventFilter = TypedEventFilter<AcceptAdminRoleEvent>;

export interface ConsolidatePendingStateEventObject {
  numBatch: BigNumber;
  stateRoot: string;
  pendingStateNum: BigNumber;
}
export type ConsolidatePendingStateEvent = TypedEvent<
  [BigNumber, string, BigNumber],
  ConsolidatePendingStateEventObject
>;

export type ConsolidatePendingStateEventFilter =
  TypedEventFilter<ConsolidatePendingStateEvent>;

export interface EmergencyStateActivatedEventObject {}
export type EmergencyStateActivatedEvent = TypedEvent<
  [],
  EmergencyStateActivatedEventObject
>;

export type EmergencyStateActivatedEventFilter =
  TypedEventFilter<EmergencyStateActivatedEvent>;

export interface EmergencyStateDeactivatedEventObject {}
export type EmergencyStateDeactivatedEvent = TypedEvent<
  [],
  EmergencyStateDeactivatedEventObject
>;

export type EmergencyStateDeactivatedEventFilter =
  TypedEventFilter<EmergencyStateDeactivatedEvent>;

export interface ForceBatchEventObject {
  forceBatchNum: BigNumber;
  lastGlobalExitRoot: string;
  sequencer: string;
  transactions: string;
}
export type ForceBatchEvent = TypedEvent<
  [BigNumber, string, string, string],
  ForceBatchEventObject
>;

export type ForceBatchEventFilter = TypedEventFilter<ForceBatchEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OverridePendingStateEventObject {
  numBatch: BigNumber;
  stateRoot: string;
  aggregator: string;
}
export type OverridePendingStateEvent = TypedEvent<
  [BigNumber, string, string],
  OverridePendingStateEventObject
>;

export type OverridePendingStateEventFilter =
  TypedEventFilter<OverridePendingStateEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface ProveNonDeterministicPendingStateEventObject {
  storedStateRoot: string;
  provedStateRoot: string;
}
export type ProveNonDeterministicPendingStateEvent = TypedEvent<
  [string, string],
  ProveNonDeterministicPendingStateEventObject
>;

export type ProveNonDeterministicPendingStateEventFilter =
  TypedEventFilter<ProveNonDeterministicPendingStateEvent>;

export interface SequenceBatchesEventObject {
  numBatch: BigNumber;
}
export type SequenceBatchesEvent = TypedEvent<
  [BigNumber],
  SequenceBatchesEventObject
>;

export type SequenceBatchesEventFilter = TypedEventFilter<SequenceBatchesEvent>;

export interface SequenceForceBatchesEventObject {
  numBatch: BigNumber;
}
export type SequenceForceBatchesEvent = TypedEvent<
  [BigNumber],
  SequenceForceBatchesEventObject
>;

export type SequenceForceBatchesEventFilter =
  TypedEventFilter<SequenceForceBatchesEvent>;

export interface SetMultiplierBatchFeeEventObject {
  newMultiplierBatchFee: number;
}
export type SetMultiplierBatchFeeEvent = TypedEvent<
  [number],
  SetMultiplierBatchFeeEventObject
>;

export type SetMultiplierBatchFeeEventFilter =
  TypedEventFilter<SetMultiplierBatchFeeEvent>;

export interface SetPendingStateTimeoutEventObject {
  newPendingStateTimeout: BigNumber;
}
export type SetPendingStateTimeoutEvent = TypedEvent<
  [BigNumber],
  SetPendingStateTimeoutEventObject
>;

export type SetPendingStateTimeoutEventFilter =
  TypedEventFilter<SetPendingStateTimeoutEvent>;

export interface SetTrustedAggregatorEventObject {
  newTrustedAggregator: string;
}
export type SetTrustedAggregatorEvent = TypedEvent<
  [string],
  SetTrustedAggregatorEventObject
>;

export type SetTrustedAggregatorEventFilter =
  TypedEventFilter<SetTrustedAggregatorEvent>;

export interface SetTrustedAggregatorTimeoutEventObject {
  newTrustedAggregatorTimeout: BigNumber;
}
export type SetTrustedAggregatorTimeoutEvent = TypedEvent<
  [BigNumber],
  SetTrustedAggregatorTimeoutEventObject
>;

export type SetTrustedAggregatorTimeoutEventFilter =
  TypedEventFilter<SetTrustedAggregatorTimeoutEvent>;

export interface SetTrustedSequencerEventObject {
  newTrustedSequencer: string;
}
export type SetTrustedSequencerEvent = TypedEvent<
  [string],
  SetTrustedSequencerEventObject
>;

export type SetTrustedSequencerEventFilter =
  TypedEventFilter<SetTrustedSequencerEvent>;

export interface SetTrustedSequencerURLEventObject {
  newTrustedSequencerURL: string;
}
export type SetTrustedSequencerURLEvent = TypedEvent<
  [string],
  SetTrustedSequencerURLEventObject
>;

export type SetTrustedSequencerURLEventFilter =
  TypedEventFilter<SetTrustedSequencerURLEvent>;

export interface SetVerifyBatchTimeTargetEventObject {
  newVerifyBatchTimeTarget: BigNumber;
}
export type SetVerifyBatchTimeTargetEvent = TypedEvent<
  [BigNumber],
  SetVerifyBatchTimeTargetEventObject
>;

export type SetVerifyBatchTimeTargetEventFilter =
  TypedEventFilter<SetVerifyBatchTimeTargetEvent>;

export interface TransferAdminRoleEventObject {
  newPendingAdmin: string;
}
export type TransferAdminRoleEvent = TypedEvent<
  [string],
  TransferAdminRoleEventObject
>;

export type TransferAdminRoleEventFilter =
  TypedEventFilter<TransferAdminRoleEvent>;

export interface UpdateZkEVMVersionEventObject {
  numBatch: BigNumber;
  forkID: BigNumber;
  version: string;
}
export type UpdateZkEVMVersionEvent = TypedEvent<
  [BigNumber, BigNumber, string],
  UpdateZkEVMVersionEventObject
>;

export type UpdateZkEVMVersionEventFilter =
  TypedEventFilter<UpdateZkEVMVersionEvent>;

export interface VerifyBatchesEventObject {
  numBatch: BigNumber;
  stateRoot: string;
  aggregator: string;
}
export type VerifyBatchesEvent = TypedEvent<
  [BigNumber, string, string],
  VerifyBatchesEventObject
>;

export type VerifyBatchesEventFilter = TypedEventFilter<VerifyBatchesEvent>;

export interface VerifyBatchesTrustedAggregatorEventObject {
  numBatch: BigNumber;
  stateRoot: string;
  aggregator: string;
}
export type VerifyBatchesTrustedAggregatorEvent = TypedEvent<
  [BigNumber, string, string],
  VerifyBatchesTrustedAggregatorEventObject
>;

export type VerifyBatchesTrustedAggregatorEventFilter =
  TypedEventFilter<VerifyBatchesTrustedAggregatorEvent>;

export interface ProofOfEfficiency extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ProofOfEfficiencyInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptAdminRole(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    activateEmergencyState(
      sequencedBatchNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    admin(overrides?: CallOverrides): Promise<[string]>;

    batchFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    batchNumToStateRoot(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    bridgeAddress(overrides?: CallOverrides): Promise<[string]>;

    calculateRewardPerBatch(overrides?: CallOverrides): Promise<[BigNumber]>;

    chainID(overrides?: CallOverrides): Promise<[BigNumber]>;

    consolidatePendingState(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deactivateEmergencyState(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceBatch(
      transactions: PromiseOrValue<BytesLike>,
      maticAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forcedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    forkID(overrides?: CallOverrides): Promise<[BigNumber]>;

    getCurrentBatchFee(overrides?: CallOverrides): Promise<[BigNumber]>;

    getInputSnarkBytes(
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      oldStateRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getLastVerifiedBatch(overrides?: CallOverrides): Promise<[BigNumber]>;

    globalExitRootManager(overrides?: CallOverrides): Promise<[string]>;

    initialize(
      initializePackedParameters: PolygonZkEVM.InitializePackedParametersStruct,
      genesisRoot: PromiseOrValue<BytesLike>,
      _trustedSequencerURL: PromiseOrValue<string>,
      _networkName: PromiseOrValue<string>,
      _version: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isEmergencyState(overrides?: CallOverrides): Promise<[boolean]>;

    isPendingStateConsolidable(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    lastBatchSequenced(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastForceBatch(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastForceBatchSequenced(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastPendingState(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastPendingStateConsolidated(
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    lastTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    lastVerifiedBatch(overrides?: CallOverrides): Promise<[BigNumber]>;

    matic(overrides?: CallOverrides): Promise<[string]>;

    multiplierBatchFee(overrides?: CallOverrides): Promise<[number]>;

    networkName(overrides?: CallOverrides): Promise<[string]>;

    overridePendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingAdmin(overrides?: CallOverrides): Promise<[string]>;

    pendingStateTimeout(overrides?: CallOverrides): Promise<[BigNumber]>;

    pendingStateTransitions(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string] & {
        timestamp: BigNumber;
        lastVerifiedBatch: BigNumber;
        exitRoot: string;
        stateRoot: string;
      }
    >;

    proveNonDeterministicPendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rollupVerifier(overrides?: CallOverrides): Promise<[string]>;

    sequenceBatches(
      batches: PolygonZkEVM.BatchDataStruct[],
      feeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    sequenceForceBatches(
      batches: PolygonZkEVM.ForcedBatchDataStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    sequencedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber] & {
        accInputHash: string;
        sequencedTimestamp: BigNumber;
        previousLastBatchSequenced: BigNumber;
      }
    >;

    setMultiplierBatchFee(
      newMultiplierBatchFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPendingStateTimeout(
      newPendingStateTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTrustedAggregator(
      newTrustedAggregator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTrustedAggregatorTimeout(
      newTrustedAggregatorTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTrustedSequencer(
      newTrustedSequencer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTrustedSequencerURL(
      newTrustedSequencerURL: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setVerifyBatchTimeTarget(
      newVerifyBatchTimeTarget: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferAdminRole(
      newPendingAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    trustedAggregator(overrides?: CallOverrides): Promise<[string]>;

    trustedAggregatorTimeout(overrides?: CallOverrides): Promise<[BigNumber]>;

    trustedSequencer(overrides?: CallOverrides): Promise<[string]>;

    trustedSequencerURL(overrides?: CallOverrides): Promise<[string]>;

    verifyBatchTimeTarget(overrides?: CallOverrides): Promise<[BigNumber]>;

    verifyBatches(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verifyBatchesTrustedAggregator(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  acceptAdminRole(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  activateEmergencyState(
    sequencedBatchNum: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  admin(overrides?: CallOverrides): Promise<string>;

  batchFee(overrides?: CallOverrides): Promise<BigNumber>;

  batchNumToStateRoot(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  bridgeAddress(overrides?: CallOverrides): Promise<string>;

  calculateRewardPerBatch(overrides?: CallOverrides): Promise<BigNumber>;

  chainID(overrides?: CallOverrides): Promise<BigNumber>;

  consolidatePendingState(
    pendingStateNum: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deactivateEmergencyState(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceBatch(
    transactions: PromiseOrValue<BytesLike>,
    maticAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forcedBatches(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  forkID(overrides?: CallOverrides): Promise<BigNumber>;

  getCurrentBatchFee(overrides?: CallOverrides): Promise<BigNumber>;

  getInputSnarkBytes(
    initNumBatch: PromiseOrValue<BigNumberish>,
    finalNewBatch: PromiseOrValue<BigNumberish>,
    newLocalExitRoot: PromiseOrValue<BytesLike>,
    oldStateRoot: PromiseOrValue<BytesLike>,
    newStateRoot: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  getLastVerifiedBatch(overrides?: CallOverrides): Promise<BigNumber>;

  globalExitRootManager(overrides?: CallOverrides): Promise<string>;

  initialize(
    initializePackedParameters: PolygonZkEVM.InitializePackedParametersStruct,
    genesisRoot: PromiseOrValue<BytesLike>,
    _trustedSequencerURL: PromiseOrValue<string>,
    _networkName: PromiseOrValue<string>,
    _version: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isEmergencyState(overrides?: CallOverrides): Promise<boolean>;

  isPendingStateConsolidable(
    pendingStateNum: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  lastBatchSequenced(overrides?: CallOverrides): Promise<BigNumber>;

  lastForceBatch(overrides?: CallOverrides): Promise<BigNumber>;

  lastForceBatchSequenced(overrides?: CallOverrides): Promise<BigNumber>;

  lastPendingState(overrides?: CallOverrides): Promise<BigNumber>;

  lastPendingStateConsolidated(overrides?: CallOverrides): Promise<BigNumber>;

  lastTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  lastVerifiedBatch(overrides?: CallOverrides): Promise<BigNumber>;

  matic(overrides?: CallOverrides): Promise<string>;

  multiplierBatchFee(overrides?: CallOverrides): Promise<number>;

  networkName(overrides?: CallOverrides): Promise<string>;

  overridePendingState(
    initPendingStateNum: PromiseOrValue<BigNumberish>,
    finalPendingStateNum: PromiseOrValue<BigNumberish>,
    initNumBatch: PromiseOrValue<BigNumberish>,
    finalNewBatch: PromiseOrValue<BigNumberish>,
    newLocalExitRoot: PromiseOrValue<BytesLike>,
    newStateRoot: PromiseOrValue<BytesLike>,
    proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    proofB: [
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ],
    proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingAdmin(overrides?: CallOverrides): Promise<string>;

  pendingStateTimeout(overrides?: CallOverrides): Promise<BigNumber>;

  pendingStateTransitions(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, string, string] & {
      timestamp: BigNumber;
      lastVerifiedBatch: BigNumber;
      exitRoot: string;
      stateRoot: string;
    }
  >;

  proveNonDeterministicPendingState(
    initPendingStateNum: PromiseOrValue<BigNumberish>,
    finalPendingStateNum: PromiseOrValue<BigNumberish>,
    initNumBatch: PromiseOrValue<BigNumberish>,
    finalNewBatch: PromiseOrValue<BigNumberish>,
    newLocalExitRoot: PromiseOrValue<BytesLike>,
    newStateRoot: PromiseOrValue<BytesLike>,
    proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    proofB: [
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ],
    proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rollupVerifier(overrides?: CallOverrides): Promise<string>;

  sequenceBatches(
    batches: PolygonZkEVM.BatchDataStruct[],
    feeRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  sequenceForceBatches(
    batches: PolygonZkEVM.ForcedBatchDataStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  sequencedBatches(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber, BigNumber] & {
      accInputHash: string;
      sequencedTimestamp: BigNumber;
      previousLastBatchSequenced: BigNumber;
    }
  >;

  setMultiplierBatchFee(
    newMultiplierBatchFee: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPendingStateTimeout(
    newPendingStateTimeout: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTrustedAggregator(
    newTrustedAggregator: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTrustedAggregatorTimeout(
    newTrustedAggregatorTimeout: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTrustedSequencer(
    newTrustedSequencer: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTrustedSequencerURL(
    newTrustedSequencerURL: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setVerifyBatchTimeTarget(
    newVerifyBatchTimeTarget: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferAdminRole(
    newPendingAdmin: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  trustedAggregator(overrides?: CallOverrides): Promise<string>;

  trustedAggregatorTimeout(overrides?: CallOverrides): Promise<BigNumber>;

  trustedSequencer(overrides?: CallOverrides): Promise<string>;

  trustedSequencerURL(overrides?: CallOverrides): Promise<string>;

  verifyBatchTimeTarget(overrides?: CallOverrides): Promise<BigNumber>;

  verifyBatches(
    pendingStateNum: PromiseOrValue<BigNumberish>,
    initNumBatch: PromiseOrValue<BigNumberish>,
    finalNewBatch: PromiseOrValue<BigNumberish>,
    newLocalExitRoot: PromiseOrValue<BytesLike>,
    newStateRoot: PromiseOrValue<BytesLike>,
    proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    proofB: [
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ],
    proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verifyBatchesTrustedAggregator(
    pendingStateNum: PromiseOrValue<BigNumberish>,
    initNumBatch: PromiseOrValue<BigNumberish>,
    finalNewBatch: PromiseOrValue<BigNumberish>,
    newLocalExitRoot: PromiseOrValue<BytesLike>,
    newStateRoot: PromiseOrValue<BytesLike>,
    proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    proofB: [
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
    ],
    proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    acceptAdminRole(overrides?: CallOverrides): Promise<void>;

    activateEmergencyState(
      sequencedBatchNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    admin(overrides?: CallOverrides): Promise<string>;

    batchFee(overrides?: CallOverrides): Promise<BigNumber>;

    batchNumToStateRoot(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    bridgeAddress(overrides?: CallOverrides): Promise<string>;

    calculateRewardPerBatch(overrides?: CallOverrides): Promise<BigNumber>;

    chainID(overrides?: CallOverrides): Promise<BigNumber>;

    consolidatePendingState(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    deactivateEmergencyState(overrides?: CallOverrides): Promise<void>;

    forceBatch(
      transactions: PromiseOrValue<BytesLike>,
      maticAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    forcedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    forkID(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentBatchFee(overrides?: CallOverrides): Promise<BigNumber>;

    getInputSnarkBytes(
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      oldStateRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    getLastVerifiedBatch(overrides?: CallOverrides): Promise<BigNumber>;

    globalExitRootManager(overrides?: CallOverrides): Promise<string>;

    initialize(
      initializePackedParameters: PolygonZkEVM.InitializePackedParametersStruct,
      genesisRoot: PromiseOrValue<BytesLike>,
      _trustedSequencerURL: PromiseOrValue<string>,
      _networkName: PromiseOrValue<string>,
      _version: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    isEmergencyState(overrides?: CallOverrides): Promise<boolean>;

    isPendingStateConsolidable(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    lastBatchSequenced(overrides?: CallOverrides): Promise<BigNumber>;

    lastForceBatch(overrides?: CallOverrides): Promise<BigNumber>;

    lastForceBatchSequenced(overrides?: CallOverrides): Promise<BigNumber>;

    lastPendingState(overrides?: CallOverrides): Promise<BigNumber>;

    lastPendingStateConsolidated(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    lastVerifiedBatch(overrides?: CallOverrides): Promise<BigNumber>;

    matic(overrides?: CallOverrides): Promise<string>;

    multiplierBatchFee(overrides?: CallOverrides): Promise<number>;

    networkName(overrides?: CallOverrides): Promise<string>;

    overridePendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: CallOverrides
    ): Promise<void>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingAdmin(overrides?: CallOverrides): Promise<string>;

    pendingStateTimeout(overrides?: CallOverrides): Promise<BigNumber>;

    pendingStateTransitions(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, string, string] & {
        timestamp: BigNumber;
        lastVerifiedBatch: BigNumber;
        exitRoot: string;
        stateRoot: string;
      }
    >;

    proveNonDeterministicPendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    rollupVerifier(overrides?: CallOverrides): Promise<string>;

    sequenceBatches(
      batches: PolygonZkEVM.BatchDataStruct[],
      feeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    sequenceForceBatches(
      batches: PolygonZkEVM.ForcedBatchDataStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    sequencedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber, BigNumber] & {
        accInputHash: string;
        sequencedTimestamp: BigNumber;
        previousLastBatchSequenced: BigNumber;
      }
    >;

    setMultiplierBatchFee(
      newMultiplierBatchFee: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPendingStateTimeout(
      newPendingStateTimeout: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTrustedAggregator(
      newTrustedAggregator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTrustedAggregatorTimeout(
      newTrustedAggregatorTimeout: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTrustedSequencer(
      newTrustedSequencer: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTrustedSequencerURL(
      newTrustedSequencerURL: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setVerifyBatchTimeTarget(
      newVerifyBatchTimeTarget: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferAdminRole(
      newPendingAdmin: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    trustedAggregator(overrides?: CallOverrides): Promise<string>;

    trustedAggregatorTimeout(overrides?: CallOverrides): Promise<BigNumber>;

    trustedSequencer(overrides?: CallOverrides): Promise<string>;

    trustedSequencerURL(overrides?: CallOverrides): Promise<string>;

    verifyBatchTimeTarget(overrides?: CallOverrides): Promise<BigNumber>;

    verifyBatches(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: CallOverrides
    ): Promise<void>;

    verifyBatchesTrustedAggregator(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AcceptAdminRole(address)"(newAdmin?: null): AcceptAdminRoleEventFilter;
    AcceptAdminRole(newAdmin?: null): AcceptAdminRoleEventFilter;

    "ConsolidatePendingState(uint64,bytes32,uint64)"(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      pendingStateNum?: PromiseOrValue<BigNumberish> | null
    ): ConsolidatePendingStateEventFilter;
    ConsolidatePendingState(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      pendingStateNum?: PromiseOrValue<BigNumberish> | null
    ): ConsolidatePendingStateEventFilter;

    "EmergencyStateActivated()"(): EmergencyStateActivatedEventFilter;
    EmergencyStateActivated(): EmergencyStateActivatedEventFilter;

    "EmergencyStateDeactivated()"(): EmergencyStateDeactivatedEventFilter;
    EmergencyStateDeactivated(): EmergencyStateDeactivatedEventFilter;

    "ForceBatch(uint64,bytes32,address,bytes)"(
      forceBatchNum?: PromiseOrValue<BigNumberish> | null,
      lastGlobalExitRoot?: null,
      sequencer?: null,
      transactions?: null
    ): ForceBatchEventFilter;
    ForceBatch(
      forceBatchNum?: PromiseOrValue<BigNumberish> | null,
      lastGlobalExitRoot?: null,
      sequencer?: null,
      transactions?: null
    ): ForceBatchEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OverridePendingState(uint64,bytes32,address)"(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      aggregator?: PromiseOrValue<string> | null
    ): OverridePendingStateEventFilter;
    OverridePendingState(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      aggregator?: PromiseOrValue<string> | null
    ): OverridePendingStateEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "ProveNonDeterministicPendingState(bytes32,bytes32)"(
      storedStateRoot?: null,
      provedStateRoot?: null
    ): ProveNonDeterministicPendingStateEventFilter;
    ProveNonDeterministicPendingState(
      storedStateRoot?: null,
      provedStateRoot?: null
    ): ProveNonDeterministicPendingStateEventFilter;

    "SequenceBatches(uint64)"(
      numBatch?: PromiseOrValue<BigNumberish> | null
    ): SequenceBatchesEventFilter;
    SequenceBatches(
      numBatch?: PromiseOrValue<BigNumberish> | null
    ): SequenceBatchesEventFilter;

    "SequenceForceBatches(uint64)"(
      numBatch?: PromiseOrValue<BigNumberish> | null
    ): SequenceForceBatchesEventFilter;
    SequenceForceBatches(
      numBatch?: PromiseOrValue<BigNumberish> | null
    ): SequenceForceBatchesEventFilter;

    "SetMultiplierBatchFee(uint16)"(
      newMultiplierBatchFee?: null
    ): SetMultiplierBatchFeeEventFilter;
    SetMultiplierBatchFee(
      newMultiplierBatchFee?: null
    ): SetMultiplierBatchFeeEventFilter;

    "SetPendingStateTimeout(uint64)"(
      newPendingStateTimeout?: null
    ): SetPendingStateTimeoutEventFilter;
    SetPendingStateTimeout(
      newPendingStateTimeout?: null
    ): SetPendingStateTimeoutEventFilter;

    "SetTrustedAggregator(address)"(
      newTrustedAggregator?: null
    ): SetTrustedAggregatorEventFilter;
    SetTrustedAggregator(
      newTrustedAggregator?: null
    ): SetTrustedAggregatorEventFilter;

    "SetTrustedAggregatorTimeout(uint64)"(
      newTrustedAggregatorTimeout?: null
    ): SetTrustedAggregatorTimeoutEventFilter;
    SetTrustedAggregatorTimeout(
      newTrustedAggregatorTimeout?: null
    ): SetTrustedAggregatorTimeoutEventFilter;

    "SetTrustedSequencer(address)"(
      newTrustedSequencer?: null
    ): SetTrustedSequencerEventFilter;
    SetTrustedSequencer(
      newTrustedSequencer?: null
    ): SetTrustedSequencerEventFilter;

    "SetTrustedSequencerURL(string)"(
      newTrustedSequencerURL?: null
    ): SetTrustedSequencerURLEventFilter;
    SetTrustedSequencerURL(
      newTrustedSequencerURL?: null
    ): SetTrustedSequencerURLEventFilter;

    "SetVerifyBatchTimeTarget(uint64)"(
      newVerifyBatchTimeTarget?: null
    ): SetVerifyBatchTimeTargetEventFilter;
    SetVerifyBatchTimeTarget(
      newVerifyBatchTimeTarget?: null
    ): SetVerifyBatchTimeTargetEventFilter;

    "TransferAdminRole(address)"(
      newPendingAdmin?: null
    ): TransferAdminRoleEventFilter;
    TransferAdminRole(newPendingAdmin?: null): TransferAdminRoleEventFilter;

    "UpdateZkEVMVersion(uint64,uint64,string)"(
      numBatch?: null,
      forkID?: null,
      version?: null
    ): UpdateZkEVMVersionEventFilter;
    UpdateZkEVMVersion(
      numBatch?: null,
      forkID?: null,
      version?: null
    ): UpdateZkEVMVersionEventFilter;

    "VerifyBatches(uint64,bytes32,address)"(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      aggregator?: PromiseOrValue<string> | null
    ): VerifyBatchesEventFilter;
    VerifyBatches(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      aggregator?: PromiseOrValue<string> | null
    ): VerifyBatchesEventFilter;

    "VerifyBatchesTrustedAggregator(uint64,bytes32,address)"(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      aggregator?: PromiseOrValue<string> | null
    ): VerifyBatchesTrustedAggregatorEventFilter;
    VerifyBatchesTrustedAggregator(
      numBatch?: PromiseOrValue<BigNumberish> | null,
      stateRoot?: null,
      aggregator?: PromiseOrValue<string> | null
    ): VerifyBatchesTrustedAggregatorEventFilter;
  };

  estimateGas: {
    acceptAdminRole(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    activateEmergencyState(
      sequencedBatchNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    admin(overrides?: CallOverrides): Promise<BigNumber>;

    batchFee(overrides?: CallOverrides): Promise<BigNumber>;

    batchNumToStateRoot(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    bridgeAddress(overrides?: CallOverrides): Promise<BigNumber>;

    calculateRewardPerBatch(overrides?: CallOverrides): Promise<BigNumber>;

    chainID(overrides?: CallOverrides): Promise<BigNumber>;

    consolidatePendingState(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deactivateEmergencyState(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceBatch(
      transactions: PromiseOrValue<BytesLike>,
      maticAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forcedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    forkID(overrides?: CallOverrides): Promise<BigNumber>;

    getCurrentBatchFee(overrides?: CallOverrides): Promise<BigNumber>;

    getInputSnarkBytes(
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      oldStateRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLastVerifiedBatch(overrides?: CallOverrides): Promise<BigNumber>;

    globalExitRootManager(overrides?: CallOverrides): Promise<BigNumber>;

    initialize(
      initializePackedParameters: PolygonZkEVM.InitializePackedParametersStruct,
      genesisRoot: PromiseOrValue<BytesLike>,
      _trustedSequencerURL: PromiseOrValue<string>,
      _networkName: PromiseOrValue<string>,
      _version: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isEmergencyState(overrides?: CallOverrides): Promise<BigNumber>;

    isPendingStateConsolidable(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastBatchSequenced(overrides?: CallOverrides): Promise<BigNumber>;

    lastForceBatch(overrides?: CallOverrides): Promise<BigNumber>;

    lastForceBatchSequenced(overrides?: CallOverrides): Promise<BigNumber>;

    lastPendingState(overrides?: CallOverrides): Promise<BigNumber>;

    lastPendingStateConsolidated(overrides?: CallOverrides): Promise<BigNumber>;

    lastTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    lastVerifiedBatch(overrides?: CallOverrides): Promise<BigNumber>;

    matic(overrides?: CallOverrides): Promise<BigNumber>;

    multiplierBatchFee(overrides?: CallOverrides): Promise<BigNumber>;

    networkName(overrides?: CallOverrides): Promise<BigNumber>;

    overridePendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingAdmin(overrides?: CallOverrides): Promise<BigNumber>;

    pendingStateTimeout(overrides?: CallOverrides): Promise<BigNumber>;

    pendingStateTransitions(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proveNonDeterministicPendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rollupVerifier(overrides?: CallOverrides): Promise<BigNumber>;

    sequenceBatches(
      batches: PolygonZkEVM.BatchDataStruct[],
      feeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    sequenceForceBatches(
      batches: PolygonZkEVM.ForcedBatchDataStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    sequencedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setMultiplierBatchFee(
      newMultiplierBatchFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPendingStateTimeout(
      newPendingStateTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTrustedAggregator(
      newTrustedAggregator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTrustedAggregatorTimeout(
      newTrustedAggregatorTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTrustedSequencer(
      newTrustedSequencer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTrustedSequencerURL(
      newTrustedSequencerURL: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setVerifyBatchTimeTarget(
      newVerifyBatchTimeTarget: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferAdminRole(
      newPendingAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    trustedAggregator(overrides?: CallOverrides): Promise<BigNumber>;

    trustedAggregatorTimeout(overrides?: CallOverrides): Promise<BigNumber>;

    trustedSequencer(overrides?: CallOverrides): Promise<BigNumber>;

    trustedSequencerURL(overrides?: CallOverrides): Promise<BigNumber>;

    verifyBatchTimeTarget(overrides?: CallOverrides): Promise<BigNumber>;

    verifyBatches(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verifyBatchesTrustedAggregator(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptAdminRole(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    activateEmergencyState(
      sequencedBatchNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    admin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    batchFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    batchNumToStateRoot(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    bridgeAddress(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    calculateRewardPerBatch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    chainID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    consolidatePendingState(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deactivateEmergencyState(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceBatch(
      transactions: PromiseOrValue<BytesLike>,
      maticAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forcedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    forkID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCurrentBatchFee(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInputSnarkBytes(
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      oldStateRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLastVerifiedBatch(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    globalExitRootManager(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      initializePackedParameters: PolygonZkEVM.InitializePackedParametersStruct,
      genesisRoot: PromiseOrValue<BytesLike>,
      _trustedSequencerURL: PromiseOrValue<string>,
      _networkName: PromiseOrValue<string>,
      _version: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isEmergencyState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isPendingStateConsolidable(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastBatchSequenced(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastForceBatch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastForceBatchSequenced(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastPendingState(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastPendingStateConsolidated(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lastVerifiedBatch(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    matic(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multiplierBatchFee(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    networkName(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    overridePendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingAdmin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingStateTimeout(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pendingStateTransitions(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proveNonDeterministicPendingState(
      initPendingStateNum: PromiseOrValue<BigNumberish>,
      finalPendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rollupVerifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sequenceBatches(
      batches: PolygonZkEVM.BatchDataStruct[],
      feeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    sequenceForceBatches(
      batches: PolygonZkEVM.ForcedBatchDataStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    sequencedBatches(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setMultiplierBatchFee(
      newMultiplierBatchFee: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPendingStateTimeout(
      newPendingStateTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTrustedAggregator(
      newTrustedAggregator: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTrustedAggregatorTimeout(
      newTrustedAggregatorTimeout: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTrustedSequencer(
      newTrustedSequencer: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTrustedSequencerURL(
      newTrustedSequencerURL: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setVerifyBatchTimeTarget(
      newVerifyBatchTimeTarget: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferAdminRole(
      newPendingAdmin: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    trustedAggregator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    trustedAggregatorTimeout(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    trustedSequencer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    trustedSequencerURL(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyBatchTimeTarget(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyBatches(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verifyBatchesTrustedAggregator(
      pendingStateNum: PromiseOrValue<BigNumberish>,
      initNumBatch: PromiseOrValue<BigNumberish>,
      finalNewBatch: PromiseOrValue<BigNumberish>,
      newLocalExitRoot: PromiseOrValue<BytesLike>,
      newStateRoot: PromiseOrValue<BytesLike>,
      proofA: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      proofB: [
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
        [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
      ],
      proofC: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
